/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.5.8.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export interface Batch {
  batch_id: number;
  setoffs: [number, number][];
  [k: string]: unknown;
}
export interface DenomResponse {
  denom: string;
  [k: string]: unknown;
}
export type Addr = string;
export interface Edge {
  amount: number;
  creditor: Addr;
  debtor: Addr;
  edge_id: number;
  graph_id?: number | null;
  [k: string]: unknown;
}
export type ExecuteMsg = {
  create_edge: {
    amount: number;
    creditor: Addr;
    [k: string]: unknown;
  };
} | {
  edit_edge: {
    amount: number;
    creditor: Addr;
    edge_id: number;
    [k: string]: unknown;
  };
} | {
  remove_edge: {
    edge_id: number;
    [k: string]: unknown;
  };
} | {
  create_graph: {
    graph: Edge[];
    [k: string]: unknown;
  };
} | {
  create_graph_simplified: {
    graph: [Addr, Addr, number][];
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  edit_graph_simplified: {
    graph: [Addr, Addr, number][];
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  remove_graph: {
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  update_edges: {
    edges: [number, number][];
    [k: string]: unknown;
  };
} | {
  find_savings: {
    [k: string]: unknown;
  };
} | {
  find_savings_in_a_graph: {
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  reset: {
    [k: string]: unknown;
  };
} | {
  save_network_to_file: {
    filepath: string;
    [k: string]: unknown;
  };
} | {
  create_graph_from_file: {
    filepath: string;
    [k: string]: unknown;
  };
} | {
  apply_set_off_from_file: {
    filepath: string;
    [k: string]: unknown;
  };
};
export interface InstantiateMsg {
  denom: string;
  [k: string]: unknown;
}
export interface Network {
  denom: string;
  owner: Addr;
  [k: string]: unknown;
}
export type QueryMsg = {
  get_denom: {
    [k: string]: unknown;
  };
} | {
  get_owner: {
    [k: string]: unknown;
  };
} | {
  all_edges: {
    [k: string]: unknown;
  };
} | {
  one_edge: {
    edge_id: number;
    [k: string]: unknown;
  };
} | {
  one_batch: {
    batch_id: number;
    [k: string]: unknown;
  };
} | {
  one_graph: {
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  get_edges_by_address: {
    address: Addr;
    [k: string]: unknown;
  };
} | {
  get_edges_as_counterparty: {
    address: Addr;
    [k: string]: unknown;
  };
} | {
  get_total_debt_per_address: {
    address: Addr;
    [k: string]: unknown;
  };
} | {
  get_total_credit_per_address: {
    address: Addr;
    [k: string]: unknown;
  };
} | {
  get_total_debt_by_graph: {
    graph_id: number;
    [k: string]: unknown;
  };
} | {
  get_total_debt: {
    [k: string]: unknown;
  };
};
export interface ObligattoReadOnlyInterface {
  contractAddress: string;
  getDenom: () => Promise<GetDenomResponse>;
  getOwner: () => Promise<GetOwnerResponse>;
  allEdges: () => Promise<AllEdgesResponse>;
  oneEdge: ({
    edgeId
  }: {
    edgeId: number;
  }) => Promise<OneEdgeResponse>;
  oneBatch: ({
    batchId
  }: {
    batchId: number;
  }) => Promise<OneBatchResponse>;
  oneGraph: ({
    graphId
  }: {
    graphId: number;
  }) => Promise<OneGraphResponse>;
  getEdgesByAddress: ({
    address
  }: {
    address: string;
  }) => Promise<GetEdgesByAddressResponse>;
  getEdgesAsCounterparty: ({
    address
  }: {
    address: string;
  }) => Promise<GetEdgesAsCounterpartyResponse>;
  getTotalDebtPerAddress: ({
    address
  }: {
    address: string;
  }) => Promise<GetTotalDebtPerAddressResponse>;
  getTotalCreditPerAddress: ({
    address
  }: {
    address: string;
  }) => Promise<GetTotalCreditPerAddressResponse>;
  getTotalDebtByGraph: ({
    graphId
  }: {
    graphId: number;
  }) => Promise<GetTotalDebtByGraphResponse>;
  getTotalDebt: () => Promise<GetTotalDebtResponse>;
}
export class ObligattoQueryClient implements ObligattoReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getDenom = this.getDenom.bind(this);
    this.getOwner = this.getOwner.bind(this);
    this.allEdges = this.allEdges.bind(this);
    this.oneEdge = this.oneEdge.bind(this);
    this.oneBatch = this.oneBatch.bind(this);
    this.oneGraph = this.oneGraph.bind(this);
    this.getEdgesByAddress = this.getEdgesByAddress.bind(this);
    this.getEdgesAsCounterparty = this.getEdgesAsCounterparty.bind(this);
    this.getTotalDebtPerAddress = this.getTotalDebtPerAddress.bind(this);
    this.getTotalCreditPerAddress = this.getTotalCreditPerAddress.bind(this);
    this.getTotalDebtByGraph = this.getTotalDebtByGraph.bind(this);
    this.getTotalDebt = this.getTotalDebt.bind(this);
  }

  getDenom = async (): Promise<GetDenomResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_denom: {}
    });
  };
  getOwner = async (): Promise<GetOwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owner: {}
    });
  };
  allEdges = async (): Promise<AllEdgesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_edges: {}
    });
  };
  oneEdge = async ({
    edgeId
  }: {
    edgeId: number;
  }): Promise<OneEdgeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      one_edge: {
        edge_id: edgeId
      }
    });
  };
  oneBatch = async ({
    batchId
  }: {
    batchId: number;
  }): Promise<OneBatchResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      one_batch: {
        batch_id: batchId
      }
    });
  };
  oneGraph = async ({
    graphId
  }: {
    graphId: number;
  }): Promise<OneGraphResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      one_graph: {
        graph_id: graphId
      }
    });
  };
  getEdgesByAddress = async ({
    address
  }: {
    address: string;
  }): Promise<GetEdgesByAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_edges_by_address: {
        address
      }
    });
  };
  getEdgesAsCounterparty = async ({
    address
  }: {
    address: string;
  }): Promise<GetEdgesAsCounterpartyResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_edges_as_counterparty: {
        address
      }
    });
  };
  getTotalDebtPerAddress = async ({
    address
  }: {
    address: string;
  }): Promise<GetTotalDebtPerAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_debt_per_address: {
        address
      }
    });
  };
  getTotalCreditPerAddress = async ({
    address
  }: {
    address: string;
  }): Promise<GetTotalCreditPerAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_credit_per_address: {
        address
      }
    });
  };
  getTotalDebtByGraph = async ({
    graphId
  }: {
    graphId: number;
  }): Promise<GetTotalDebtByGraphResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_debt_by_graph: {
        graph_id: graphId
      }
    });
  };
  getTotalDebt = async (): Promise<GetTotalDebtResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_debt: {}
    });
  };
}
export interface ObligattoInterface extends ObligattoReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createEdge: ({
    amount,
    creditor
  }: {
    amount: number;
    creditor: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  editEdge: ({
    amount,
    creditor,
    edgeId
  }: {
    amount: number;
    creditor: string;
    edgeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  removeEdge: ({
    edgeId
  }: {
    edgeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  createGraph: ({
    graph
  }: {
    graph: Edge[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  createGraphSimplified: ({
    graph,
    graphId
  }: {
    graph: string[][];
    graphId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  editGraphSimplified: ({
    graph,
    graphId
  }: {
    graph: string[][];
    graphId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  removeGraph: ({
    graphId
  }: {
    graphId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateEdges: ({
    edges
  }: {
    edges: number[][];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  findSavings: (fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  findSavingsInAGraph: ({
    graphId
  }: {
    graphId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  reset: (fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  saveNetworkToFile: ({
    filepath
  }: {
    filepath: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  createGraphFromFile: ({
    filepath
  }: {
    filepath: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  applySetOffFromFile: ({
    filepath
  }: {
    filepath: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
export class ObligattoClient extends ObligattoQueryClient implements ObligattoInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createEdge = this.createEdge.bind(this);
    this.editEdge = this.editEdge.bind(this);
    this.removeEdge = this.removeEdge.bind(this);
    this.createGraph = this.createGraph.bind(this);
    this.createGraphSimplified = this.createGraphSimplified.bind(this);
    this.editGraphSimplified = this.editGraphSimplified.bind(this);
    this.removeGraph = this.removeGraph.bind(this);
    this.updateEdges = this.updateEdges.bind(this);
    this.findSavings = this.findSavings.bind(this);
    this.findSavingsInAGraph = this.findSavingsInAGraph.bind(this);
    this.reset = this.reset.bind(this);
    this.saveNetworkToFile = this.saveNetworkToFile.bind(this);
    this.createGraphFromFile = this.createGraphFromFile.bind(this);
    this.applySetOffFromFile = this.applySetOffFromFile.bind(this);
  }

  createEdge = async ({
    amount,
    creditor
  }: {
    amount: number;
    creditor: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_edge: {
        amount,
        creditor
      }
    }, fee, memo, funds);
  };
  editEdge = async ({
    amount,
    creditor,
    edgeId
  }: {
    amount: number;
    creditor: string;
    edgeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_edge: {
        amount,
        creditor,
        edge_id: edgeId
      }
    }, fee, memo, funds);
  };
  removeEdge = async ({
    edgeId
  }: {
    edgeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_edge: {
        edge_id: edgeId
      }
    }, fee, memo, funds);
  };
  createGraph = async ({
    graph
  }: {
    graph: Edge[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_graph: {
        graph
      }
    }, fee, memo, funds);
  };
  createGraphSimplified = async ({
    graph,
    graphId
  }: {
    graph: string[][];
    graphId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_graph_simplified: {
        graph,
        graph_id: graphId
      }
    }, fee, memo, funds);
  };
  editGraphSimplified = async ({
    graph,
    graphId
  }: {
    graph: string[][];
    graphId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_graph_simplified: {
        graph,
        graph_id: graphId
      }
    }, fee, memo, funds);
  };
  removeGraph = async ({
    graphId
  }: {
    graphId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_graph: {
        graph_id: graphId
      }
    }, fee, memo, funds);
  };
  updateEdges = async ({
    edges
  }: {
    edges: number[][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_edges: {
        edges
      }
    }, fee, memo, funds);
  };
  findSavings = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      find_savings: {}
    }, fee, memo, funds);
  };
  findSavingsInAGraph = async ({
    graphId
  }: {
    graphId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      find_savings_in_a_graph: {
        graph_id: graphId
      }
    }, fee, memo, funds);
  };
  reset = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reset: {}
    }, fee, memo, funds);
  };
  saveNetworkToFile = async ({
    filepath
  }: {
    filepath: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_network_to_file: {
        filepath
      }
    }, fee, memo, funds);
  };
  createGraphFromFile = async ({
    filepath
  }: {
    filepath: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_graph_from_file: {
        filepath
      }
    }, fee, memo, funds);
  };
  applySetOffFromFile = async ({
    filepath
  }: {
    filepath: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      apply_set_off_from_file: {
        filepath
      }
    }, fee, memo, funds);
  };
}